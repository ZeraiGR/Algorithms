// НОП с восстановлением ответа

// Даны две последовательности, требуется найти и вывести их наибольшую общую подпоследовательность.

// Формат ввода
// В первой строке входных данных содержится число N – длина первой последовательности (1 ≤ N ≤ 1000). Во второй строке заданы члены первой последовательности (через пробел) – целые числа, не превосходящие 10000 по модулю.

// В третьей строке записано число M – длина второй последовательности (1 ≤ M ≤ 1000). В четвертой строке задаются члены второй последовательности (через пробел) – целые числа, не превосходящие 10000 по модулю.

// Формат вывода
// Требуется вывести наибольшую общую подпоследовательность данных последовательностей, через пробел.

const fs = require('fs');

let fileContent = fs.readFileSync("input.txt", {encoding: 'utf-8'}, );

let [n, seq1, m, seq2] = fileContent.trim().split('\n');

n = +n;
m = +m;
seq1 = seq1.split(' ').map(n => +n);
seq2 = seq2.split(' ').map(n => +n);

let dp = [];

for (let i = 0; i < m + 1; i++) {
  dp.push(new Array(n + 1).fill(0));
}

for (let i = 1; i < m + 1; i++) {
  for (let j = 1; j < n + 1; j++) {
    let letterJ = seq1[j-1];
    let letterI = seq2[i-1];
    if (letterI === letterJ) {
      dp[i][j] = dp[i-1][j-1] + 1;
    } else {
      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
    }
  }
}

let ans = [];
let i = m;
let j = n;
while (i > 0 && j > 0) {
  if (seq1[j - 1] === seq2[i - 1]) {
    ans.push(seq2[i - 1]);
    i -= 1;
    j -= 1;
  } else if (dp[i-1][j] >= dp[i][j-1]) {
    i -= 1;
  } else {
    j -= 1;
  }
}

ans.reverse();

fs.writeFileSync("output.txt", ans.join(' '));