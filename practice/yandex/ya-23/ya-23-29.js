// Кафе

// Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок: при каждой покупке более чем на 100 рублей покупатель получает купон, дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).

// Однажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его изучив, он решил, что будет обедать в этом кафе все N дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были минимальны. Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые Пете следует воспользоваться купонами.

// Формат ввода
// В первой строке входного файла записано целое число N (0 ≤ N ≤ 100). В каждой из последующих N строк записано одно целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число, не превосходящее 300.

// Формат вывода
// В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа K1 и K2 — количество купонов, которые останутся неиспользованными у Пети после этих N дней и количество использованных им купонов соответственно.

// В последующих K2 строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами. Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение K1 максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе). Если таких решений несколько, выведите любое из них.

const fs = require('fs');

let fileContent = fs.readFileSync("input.txt", {encoding: 'utf-8'} );

let [n, ...prices] = fileContent.trim().split('\n');

n = +n;

let minPrice;
let k1;
let k2;
let days = [];

if (n === 0) {
  minPrice = 0;
  k1 = 0;
  k2 = 0;
} else {
  prices = prices.map(p => +p.trim());
  let dp = [];

  for (let i = 0; i < n + 1; i++) {
    dp.push(new Array(n+1).fill(0));
    dp[i][0] = Infinity;
    dp[0][i] = Infinity;
  }

  for (let i = 0; i < n + 1; i++) {
    dp[1][i] = Infinity;
  }

  if (prices[0] > 100) dp[1][2] = prices[0]; 
  dp[1][1] = prices[0];


  for (let i = 2; i < n + 1; i++) {
    for (let j = 1; j < n + 1; j++) {
      let curPrice = prices[i-1];
      let coupon = curPrice > 100 ? dp[i-1][j-1] + curPrice : Infinity;
      let discount = j < n ? dp[i-1][j+1] : Infinity;
      dp[i][j] = Math.min(coupon, dp[i-1][j] + curPrice, discount);
    }
  }

  minPrice = Math.min(...dp[dp.length - 1]);
  k1 = dp[dp.length - 1].lastIndexOf(minPrice) - 1;
  days = [];
  k2 = 0;
  let i = dp.length - 1;
  let j = dp[dp.length - 1].lastIndexOf(minPrice);

  while (i > 1) {
    let curSum = dp[i][j];
    let curPrice = prices[i-1];
    let isCoupon = j < n ? dp[i-1][j+1] : Infinity;
    if (curSum === isCoupon) {
      days.push(i);
      k2 += 1;
      i -= 1;
      j += 1;
    } else if (curPrice > 100) {
      i -= 1;
      j -= 1;
    } else {
      i -= 1;
    }
  }

  days.reverse();
}

fs.writeFileSync("output.txt", String(minPrice) + '\n' + String(k1) + ' ' + String(k2) + '\n' + days.join('\n'))