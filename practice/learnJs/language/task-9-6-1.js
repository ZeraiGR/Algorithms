/*

Почему instanceof в примере ниже возвращает true? Мы же видим, что a не создан с помощью B().

function A() {}
function B() {}

A.prototype = B.prototype = {};

let a = new A();

alert( a instanceof B ); // true

*/

// Ответ 

/*

  По умолчанию для всех объектов, созданных с помощью функции-конструктора А, ссылкой на прототип будет A.prototype.

  А для объектов, которые созданы с помощью функции-конструктора B - B.prototype.
  
  Но, на 8 строчке происходит переопределение прототипов обоих функций к одному пустому объекту. В результате чего мы получаем, что A.prototype и B.prototype будут ссылаться на один и тот же пустой объект.

  Оператор instanceof не использует в своих проверках функцию конструктор как таковую, а лишь её prototype и в этом вся загвоздка.

  строчку "a instanceof B" можно представить как B.prototype.isPrototypeOf(a). В общем, a.__proto === A.prototype и в тоже время 
  A.prototype === B.prototype, т.к это ссылка на один и тот же объект, 
  из этого следует, что 
  a.__proto === B.prototype, и так как instanceof нашёл такое равенство, то и возвращается true.

*/